\documentclass[12pt]{article}
\usepackage[T1]{fontenc}  % Font encoding
\usepackage{mathptmx}     % Choose Times font 
\usepackage{microtype}    % Improves line breaks      
\usepackage{blindtext}    % Filler text 
\usepackage{hyperref}     % for urls with /url{}

%Margin --- 1 inch on all sides
\usepackage[letterpaper]{geometry}
\usepackage{times}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xparse}
\usepackage[font=small,labelfont=bf]{caption}
\NewDocumentCommand{\codeword}{v}{%
	\texttt{\textcolor{blue}{#1}}%
}
\geometry{top=1.0in, bottom=1.0in, left=1.0in, right=1.0in}

\usepackage{indentfirst} % Indent the first paragraph after section headings
\setlength{\parskip}{1em} % Set inter-paragraph spacing
\setlength{\parindent}{2em} % Set paragraph indentation
\usepackage{titlesec}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title page
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
	
	\titlepage{
		\vspace*{150px} % Push down title
		\centering % Centre title
		{\large \sc A description of project concepts, milestones, and goals\\}
		\vspace*{30px} % Push down sub text
		\hrulefill \\
		\vspace*{20px}
		{\Huge \uppercase{Project Proposal\\}} % Title
		\vspace*{20px}
		\hrulefill \\
		\vspace*{30px}
		February 17, 2019\\
		\vspace*{180px}
		
		\raggedright
		\hfill
		\textit{CMPT 434: Computer Networks} \\
		\vspace*{8px}
	    Christopher	Mykota-Reid
		\hfill
		Derek Eager\\
		Rowan MacLachlan\\
	}
	
	\pagebreak % Put title on its own page
	
	%\tableofcontents
	
	\pagebreak
	
    \section{Proposal Requirements:}
    For an implementation project, you should:
    \begin{itemize}
        \item Describe what concept or issue you intend to study. 
        \item Describe the objectives of your investigation. 
        \item Give a brief plan of what you will do to investigate the issue. 
        \item Describe expected measurements  or  criteria  by  which  you
            intend  to  evaluate whether you've succeeded at your objective.
    \end{itemize}

    \url{https://en.wikipedia.org/wiki/NaCl_(software)}
    - we could use this as our encryption library: this is the same as that used
      by Tox

    Blockchain technology becoming more and more widespread. Blockchain is a
    distributed database with high fault tolerance and security by design.
    
    according the CAP theorem (Brewer Theorem) it is impossible for a distributed
    system to provide all of Consistency, Availability, and Partition Tolerance
    Distributed Data Store, Hash Table, Distributed Hash Table
    Implementations of DHTs
        Kademlia:
        \url{https://github.com/savoirfairelinux/opendht/}
    
    Design issues for DHT implementations:
    - What is the application we want to consider to inform our design?  Our
      envisioned application may effect what we optimize our DHT for.
      - User profile information?
    - How many nodes store the data of a single file?  We can start with a
      single node on a network, but what do we want to achieve?  What degree of
      redundancy can be achieved and what overhead does this add?
    - Do we store an entire file on a single node, or do we distribute a single
      file hash in incomplete parts through the network?

    - address space: how large are the hash keys?  128 bits?  160 bits?
    - What kind of hash function do we use?  Do we use a cryptographically
      secure hash function such as SHA-1 or SHA-2 or do we use an unsecure hash
      function?
    - Do we hash the file's content or the file's name?  If we hash the file
      name, how do we enforce unique file identifiers?
    - Any hash function will have collisions.  How do we manage collisions?
      Do we chain hash contents at the site of storage or do we dissallow
      colliding files?
    - Any hash function will have collisions.  How do we manage collisions?
      Do we chain hash contents at the site of storage or do we dissallow
      colliding files?
    - What about the keyspace partitioning?  Is it possible for us to avoid the
      issue of key-space re-mapping (changing the node location of data) when
      adding or removing nodes from the network?
      To better grasp the issue at hand, consider the case where we use a direct
      hashing method.  If there are n nodes in the system, then we would
      normally store object o at the node hash(o) mod n.  When someone wanted to
      look up object o, they would find it at node hash(o) mod n.  However, if a
      node disappears and the number of active nodes decreases by one, we can no
      longer find the object o at hash(o) mod n.  The other side of this issue
      is to address how objects stores at a node which dissappears are remapped
      to active nodes.
      - consistent hashing vs rendezvous hashing, both methods of dealing with
        this possibility.
    Clearly, the hashing method and design we choose is a central component and
    will have large ramifications for the rest of the project.  As best we can,
    we must keep the hashing technique decoupled from the rest of the system in
    our implementation so as to avoid creating unnecessary work.

    The second largest concern for a DHT is the node discovery and linkage.
    Once a file name has been hashed to a node, how do we find that node in the
    network?  There are a myriad of algorithms designed to do just that:
    Chord vs CAN vs Tapestry vs Pastry
    - all examples of DHT protocols.  How does Kademlia tie into these?
    - Chord itself appears to be a protocol for node discovery and linkage.
      \url{(https://en.wikipedia.org/wiki/Chord_(peer-to-peer))}
      \url{(https://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf)}
    - Kademlia uses an XOR function on a GUID (per-node unique identifier) to
      calculate the distance between two nodes, because the XOR satisfies the
      requirements of an ideal distance function:
      - the distance from A to itself is 0
      - The distance from A to B is the same as the distance from B to A
      - It satisfies the triangle inequality: that the sum of the distance from
        A to B to C must be greater than the distance between any two of them,
        unless they lie on a line.
      \url{(https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf)}
      Applications using Kademlia or slightly modified version of the Kademlia
      algorithm include torrent clients such as BitTorrent, other P2P
      distributed file systems such as IPFS and Gnutella as well as P2P chat,
      voice, and file-sharing programs like Tox.
	
	\begin{thebibliography}{1}
		\bibitem{am335x_ref}
		\textbf{Texas Instruments AM335x processor Technical Reference}\\
            This will serve as a primary technical reference.
	\end{thebibliography}
\end{document}
